start: statement*

fn_definition: "fn" identifier fn_definition_args [return_user_type] block_stmt
fn_definition_args: "(" [fn_definition_arg ("," fn_definition_arg)*] ")"
fn_definition_arg: identifier user_type

fn_call_expr: expression fn_call_args
fn_call_args: "(" [expression ("," expression)*] ")"
statement: ((return_stmt | break_stmt | continue_stmt | expression | assignment | let_stmt) _TERMINATOR) | (fn_definition | block_stmt | while_stmt | if_stmt)

user_type: ":" expression
return_user_type: "->" expression

let_stmt: "let" MUT? identifier user_type? "=" expression
MUT: "mut"
assignment: identifier "=" expression

return_stmt: "return" [expression]
break_stmt: "break"
continue_stmt: "continue"

block_stmt: _block
block_expression: _block
_block: "{" statement* "}" // TODO: There is no such thing as a block expression right now

while_stmt: "while" expression block_stmt
if_stmt: "if" expression block_stmt ["else" block_stmt]

expression: literal | identifier | binary_expression | unary_expression | grouped_expression | fn_call_expr | block_expression
grouped_expression: "(" expression ")"


// TODO: Merge everything like this to handle precedence accurately

// lowest precedence
binary_expression: \
expression or expression
| expression and expression

| expression equals expression
| expression not_equals expression

| expression less expression
| expression lesseq expression
| expression greater expression
| expression greatereq expression

| expression plus expression
| expression minus expression

| expression modulus expression
| expression star expression
| expression slash expression

| expression dot expression
// highest precedence


dot: "."
star: "*"
slash: "/"
minus: "-"
plus: "+"
modulus: "%"
and: "and"
or: "or"

equals: "=="
not_equals: "!="
less: "<"
lesseq: "<="
greater: ">"
greatereq: ">="


unary_expression: unary_operator? expression
?unary_operator: minus | plus | not | ampersand | star
not: "not"
ampersand: "&"

identifier: /[a-zA-Z](\w|\d)*/

?literal: bool | number | string
!bool: "true" | "false"
?number: integer | decimal
integer: /\d+/
decimal: /\d+\.\d+/
string: "\"" /[^"]+/? "\""
// TODO: char

_TERMINATOR: /\n/ 

COMMENT: /\s*/ "//" /[^\n]/*
%ignore COMMENT

%ignore /\n/

%import common.WS_INLINE
%ignore WS_INLINE
